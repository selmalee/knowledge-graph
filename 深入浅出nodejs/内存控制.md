# 内存控制

 javascript与java一样，由垃圾回收机制来进行自动内存管理，程序员在编写代码的过程中不需要时刻关注内存的分配和释放问题。

## 1 V8的垃圾回收机制与内存限制

### 1.1 V8的内存限制

内存限制：64位系统下约为1.4GB，32系统下约为0.7GB

### 1.2 内存限制的原因

在V8中，js对象是通过堆来分配的。当我们在代码中声明变量并赋值时，所用对象的内存就分配在堆中。

表层原因是V8最初为浏览器设计，对于网页来说已经足够；

深层原因是V8的垃圾回收机制的限制。垃圾回收会引起js线程暂停执行的时间，比如1.5GB的垃圾回收堆内存需要1秒以上。所以当时直接限制堆内存。

### 1.3 V8的垃圾回收机制

在V8中，主要将内存分为新生代和老生代。

- 新生代中的对象为存活时间较短的对象，主要通过Scavenge算法进行垃圾回收
- 老生代中的对象为存活时间较长或常驻内存的对象，主要采用Mark-Sweep和Mark-Compact相结合的方式进行垃圾回收。

V8堆的整体大小就是新生代所用的内存空间加上老生代的内存空间。可以通过命令行设置新生代和老生代内存空间的最大值。

### 1.4 查看垃圾回收日志

命令行启动时添加`--trace_gc`参数



## 2 高效使用内存

### 2.1 作用域

变量名查找：js在执行时会查找该变量，最先查找的是当前作用域，如果在当前作用域中无法找到该变量的声明，会沿着作用域链向上级的作用域查找，直到查到为止。

如果变量是全局变量，由于全局作用域需要直到进程退出才能释放，将导致对象常驻内存（常驻在老生代中）。

### 2.2 闭包

作用域链上的对象访问只能向上，实现外部作用域访问内部作用域中的变量的方法叫做 __闭包__。

 ``` js 
var bar = function() {
  var local = '局部变量'
  return function() {
    return local
  }
}

var baz = bar()
console.log(baz()) // '局部变量'
 ```

闭包的问题在于，一旦有变量引用这个中间函数，这个中间函数将不会释放，同时也会使原始的作用域不会得到释放，作用域中产生的内存占用也不会得到释放。如果不小心使用，一旦增长就会有内存溢出错误。

在正常的js执行中，无法立即回收的内存有内包和全局变量引用这两种情况，要十分小心此类变量是否无限制地增加。



## 3 内存指标

- `process.memoryUsage()`可以查看内存使用情况

``` bash
{ rss: 22724608, # 进程的常驻内存部分
  heapTotal: 9682944,  # 总共申请的堆内存
  heapUsed: 5274696, # 目前堆中使用中的内存量
  external: 9314 }
```

- `os.totalmem()`查看操作系统的总内存
- `os.freemem()`查看操作系统的闲置内存



## 4 内存泄漏

造成内存泄漏的原因：

- 缓存
- 队列（数组对象）消费不及时
- 作用域未释放

解决方法：

- 限制缓存的大小；进程间无法共享内存，缓存会有重复，可以采用进程外的缓存（Redis）

- 关注队列（数组对象）状态，一旦消费速度低于生产速度将会形成堆积。比如采用数据库收集日志，数据库构建在文件系统上，写入效率远远低于文件直接写入，会形成数据库写入操作的堆积。

  - 表层解决方案是用消费速度更高的技术；

  - 深层解决方案是监控队列的长度和适时告警，另一个解决方案是任意异步调用都应该包含超时机制。

- 内存泄漏排查：

  - node-heapdump可以抓拍堆内存的快照，在chrome开发者工具中查看详情；
  - node-memwatch监听全堆垃圾回收和连续5次垃圾回收内存仍没有释放，并触发对应事件。还提供抓取快照和比较快照的功能。

## 5 操作大文件

由于Node的内存限制，无法通过`fs.readFile()`和`fs.writeFile()`进行大文件操作。

- 可以改用`fs.createReadStream()`和`fs.createWriteStream()`通过流的方式实现对大文件的操作，提高程序的健壮性。
- 如果不需要进行字符串层面的操作，则不需要借助V8来处理，可以尝试进行纯粹的Buffer操作。这不会受到V8堆内存的限制。仍要考虑物理内存的限制。


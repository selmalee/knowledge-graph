# 2 二进制

上一章介绍标志寄存器时，提到“位”，即bit。1位代表二进制书的一个字节位，即1bit表示0或1。



## 2.1 用二进制表示计算机信息的原因

计算机内部是由IC（集成电路）构成的，IC的一个引脚只有有直流电压或没电压（0V或5V）两个状态。即，IC的一个引脚只能表示2个状态，所以计算机的信息数据只能用二进制来处理。

计算机处理信息的最小单位——位，就相当于二进制中的一__位__（bit）。二进制的位数一般是8位、16位、32位。8位二进制数被称为一个__字节__。位是最小单位，字节是基本单位。

比如，奔腾32位微处理器，具有32个引脚以用于信息的输入和输出，即奔腾一次可以处理32位（4字节）的二进制数信息。

无论程序中使用的是几进制，计算机内部都会将其转换成二进制来处理。



## 2.2 什么是二进制数

`00100111 = 0 + 0 + 2^5 + 0 + 0 + 2^2 + 2^1 + 2^0`

二进制数是以2为基数的计数方法。与各个数位的数值相乘的值称为位权。



## 2.3 移位运算和乘除运算的关系

移位运算：将二进制数值的各数位进行左右移位的运算。C语言中，左移运算符是`<<`，右移是`>>`。

移位运算可以代替乘法运算和除法运算。比如，00100111左移2位是10011100，数值变成了原来的4倍。

而右移后空出来的高位的数值，是补0还是补1，则需要理解__补数__的概念。



## 2.4 补数便于计算机处理

计算机在做减法运算时，实际上内部是在做加法运算。比如`1-1`，实际上是`1+(-1)`。这就用到了二进制的补数。

补数，就是将二进制数的各数位全部取反，然后再将结果加1。比如，1用8位二进制表示就是00000001，-1就是11111111。`1-1`就是`1+(-1)`，即00000001+11111111=00000000（最高位溢出被忽略）。

通过对负数求补数，就可知道负数的绝对值是多少。比如求11111110的值是多少，只需求其补数，结果是00000010，即2，所以11111110是-2。

C语言中有能处理负数的short类型，其值的范围是-32768～32767（有一位是符号位），而unsigned short类型是0～65535。



## 2.5 逻辑右移和算术右移的区别

在右移时，需要区分逻辑位移和算术位移。左移则都在低位补0。

- 逻辑右移：当二进制数的指表示图形模式，而非数值时，移位后在高位补0。比如11111100，逻辑右移后是00111111。
-  算术右移：将二进制数作为带符号的数值进行运算，移位后要在高位填充移位前符号位的值（正数为0，负数为1）。比如11111100，算术右移后是11111111。

> 在C中，左移`<<`是逻辑/算术左移(两者完全相同)，右移`>>`是算术右移。在C++中，如果负数要进行逻辑右移，可将其转换为unsigned类型。

符号扩充：在保持值不变的前提下，将其转换成16位和32位的二进制数。无论是正数还是负数，只需用符号位的值填充高位即可。



## 2.6 逻辑运算

将二进制表示的信息作为四则运算的数值来处理就是__算术__。像图形模式那样，将数值处理为单纯的0和1简单罗列就是__逻辑__。

__算术运算__是指加减乘除四则运算。__逻辑运算__是指对二进制各数字位的0和1分别进行处理的运算（看作是图形模式），包括逻辑非（NOT）、逻辑与（AND）、逻辑或（OR）和逻辑异或（XOR）。

- 逻辑非：0变成1、1变成0的取反操作
- 逻辑与：两个都是1时，运算结果为1，否则为0
- 逻辑或：两个中至少有一个是1时，运算结果为1，否则为0
- 逻辑异或：一个是1，另一个是0，运算结果为1，否则为0

# 位、字节和字符

- 位和字节：8bit为一个字节

- 字符：大部分计算机系统都使用ASCII标准来表示文本字符，即用一个唯一的单字节大小的整数值来表示每个字符。但对于非英语类语言文本，则有更多不同的编码，比如对于中文：

  - UTF-8：0-256的中文字符用8位（单字节）表示，257+的中文字符则用16位（双字节表示）。

    ![utf-8](https://pic3.zhimg.com/80/v2-9825aa0d17bdcc46ee74331b938e951a_720w.jpg)

  - UTF-16：用16位（双字节）表示中文字符。

    ![utf-16](https://pic2.zhimg.com/80/v2-3f71c244381f21d0b34727f1a6307571_720w.jpg)

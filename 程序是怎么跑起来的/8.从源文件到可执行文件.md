# 8 从源文件到可执行文件
## 8.1 计算机只能运行本地代码
用某种编程语言编写的程序就称为 __源代码__，保存源代码的文件称为 __源文件__，如`Sample.c`。
CPU只能直接解析并运行本地代码的程序。用任何编程语言编写的源代码，最后都要翻译成本地代码。

## 8.2 本地代码的内容
如`Sample.exe`文件的内容，就是本地代码。把exe文件dump一下，即把文件的内容用每个字节用2位十六进制数来表示，就可清晰地看到，本地代码的真面目是数值的罗列。
## 8.3 编译器
编译器：把C语言等高级编程语言编写的源代码，经过语法解析、句法解析、语义解析等，转换成本地代码的程序。
编译器也是一种程序，因此需要运行环境。根据CPU的类型不同，本地代码的类型也不同，因此有X86系CPU用的C编译器，Power PC用的C编译器。不同的操作系统有不同的编译器，如Windows用的C编译器、Linux用的C编译器。
总之，编译器与编程语言、CPU、操作系统有关。

## 8.4 链接器、启动和库文件

`Sample.c`文件编译后，生成`Sample.obj`，还需要进行“链接”处理。

把多个目标文件结合，生成1个exe文件就是 __链接__，运行 __链接__的程序就是 __链接器__。如：

``` bash
ilink32 -Tpe -c -x -aa c0w32.obj Sample.obj, Sample.exe,, import32.lib cw32.lib
```

- `c0w32.obj`是程序的__启动__，即运行主函数。

- `Sample.c`中使用了`sprintf()`和`MessageBox()`。`sprintf()`的目标文件在`cw32.lib`中，`MessageBox()`的目标文件在`import32.lib`中。像`cw32.lib`和`import32.lib`这样的文件就称为 __库文件__，即把多个目标文件继承保存到一个文件中的形式。

  - `sprintf()` 是 __标准函数__ 的一种，标准函数不是通过源代码形式，而是通过库文件形式和编译器一起提供的。这样即可避免繁琐，也可避免公开标准函数的源代码内容。像`cw32.lib`这样的库文件称为 __静态资源库__。
  - `MessageBox()`是Windows提供的API的一种。Windows以函数的形式为应用提供了各种功能，称为 __API__，如`MessageBox()`就提供了显示消息框的功能。Windows的API文件存储在 __DLL__ 文件，即 __动态链接库__。`import32.lib`中存储2个信息：`MessageBox()`在`user32.dll`中；DLL文件的文件夹信息。像`import32.lib`这样的库文件就称为__导入库__。


使用DLL文件的好处：

- DLL文件中的函数可以被多个程序共用。
- 对函数的内容进行修正时，不需要重新链接使用这个函数的程序（静态资源库就需要）。

> __静态资源库__：存储着目标文件的实体，并直接和EXE文件结合的库文件形式。
>
> __动态资源库__：程序运行时动态结合的文件。

## 8.5 可执行文件的运行机制

如上生成EXE文件后，双击就会把EXE文件的内容加载到内存中运行。那exe文件中的变量和函数的内存地址是怎么分配的？

EXE文件中，给变量和函数分配了虚拟的内存地址。链接器会在EXE文件的开头，追加转换内存地址的信息，即变量和函数的相对地址，这个信息称为 __再配置信息__。链接后，变量和函数就会变成一个连续排列的组，分别是变量（数据）组和函数（处理）组。在程序运行时，分配各组基点的内存地址，虚拟的内存地址就会转换成实际的内存地址。

> 相对地址：相对于基点地址的偏移量。

总结，EXE文件的内容包括再配置信息、变量组和函数组。

## 8.6 程序运行时生成栈和堆

在程序加载到内存后，还会生成栈和堆两个组。

因此，内存中的程序就是由这4样组成的：

- 复制EXE文件：用于变量的内存空间、用于函数的内存空间。详细看[1.5 函数的调用机制](https://github.com/seminelee/knowledge-graph/blob/master/%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E4%B9%88%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/1.CPU.md#15-%E5%87%BD%E6%95%B0%E7%9A%84%E8%B0%83%E7%94%A8%E6%9C%BA%E5%88%B6)。
- 程序运行时申请分配：用于栈的内存空间、用于堆的内存空间。

> [JS中的栈、队列和堆](https://github.com/seminelee/knowledge-graph/blob/master/5.js.md#411-js%E4%B8%AD%E7%9A%84%E6%A0%88%E9%98%9F%E5%88%97%E5%92%8C%E5%A0%86)

栈和堆的区别：

- 栈：用于存储函数内部的局部变量，以及函数调用时所用的参数的内存区域。栈中对数据进行存储和清理的代码，都是由 编译器自动生成的，不需要程序员的参与。
- 堆：用来存储程序运行时的任意数据及对象的内存领域。堆的内存空间，根据程序员编写的程序来申请分配或释放。如C中是通过`malloc()`申请分配，`free()`释放；C++中是通过`new`运算符申请分配，`delete`来释放。如果没有明确释放堆的内存空间，就会产生内存泄漏。

> 垃圾回收机制：对处理完毕后不需要的堆内存空间的数据和对象进行清理，释放它们所使用的内存空间。在Java及C#中，程序运行环境会自动进行垃圾回收，避免内存泄漏。
